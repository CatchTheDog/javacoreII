分布式对象：
   远程调用代理实现方式：
     1.RMI Java的远程方法调用技术，支持Java的分布式对象之间的方法调用
     2.CORBA 通过对象请求代理架构，支持跨编程语言之间的方法调用，接口描述语言IDL
     3.WS-*  独立于编程语言，使用基于XML的通信方式，用于传输对象的格式则是简单对象访问协议SOAP,接口描述语言WSDL

  存根：客户端代理对象
  参数编组：存根将远程方法所需的参数打包成一组字节，对参数编码的过程称为参数编组，参数编组的目的是将参数转换成适合在虚拟机之间进行传递的格式。

  远程方法调用过程：
  存根制造一个信息块，它由以下几部分组成：
    被使用远程对象的标志符
    被调用的方法的描述
    编组后的参数
  然后，存根将此信息发送至服务器，在服务端，接受对象执行以下动作：
    定位要调用的远程对象
    调用所需的方法并传递客户端提供的参数
    捕获返回值或者该调用产生的异常
    将返回值编组，打包送回给客户端存根
  最后，客户端存根对来自服务器的返回值或者异常进行反编组，然后返回返回值或者抛出异常。


远程对象的接口必须扩展Remote接口，而且接口中所有方法必须声明抛出RemoteException异常。
远程方法调用的目标需要继承自UnicastRemoteObject,此类构造器使得它的对象可供远程访问。如果目标已经继承其他类，无法再继承UnicastRemoteObject类，则需要手动初始化远程目标对象，
然后将远程目标对象传递给UnicastRemoteObject的静态方法exportObject.


可以使用RMI记录器记录RMI的流量信息。
在虚拟机之间传递至有两种机制：
1.实现Remote接口的类的对象将作为远程引用传递；与在虚拟机内部传递引用类似（问题：如果在远程方法中修改了一个对象的属性，那调用者会感知到这种修改吗？）
2.实现了Serializable接口，但是没有实现Remote接口的类的对象使用序列化进行复制,如果远程方法修改了某个序列化的参数，它修改的知识传递给它的副本，而调用者不会感知到这种修改。

上述两种机制都是自动的，但是远程引用传递比本地引用传递的方法调用要慢，而且受网络等情况影响会潜在地不可靠；
而对大对象的序列化比较耗时，而且远程方法不能改变被序列化的参数，可以使用传递远程引用规避此问题。

远程对象会被GC自动回收。当本地垃圾收集器发现对某个远程引用只有本地使用时，它会通知分布式收集器这个服务器不再被客户端引用，然后分布式收集器将对象标记为垃圾。


可以使用instanceof 方法对实现了多接口的远程对象进行类型判断，已确认类型，再调用指定类型的特定方法或者使用特定属性。

远程对象equals,hashCode,clone方法：
    不能在远程方法中定义equals,hashCode方法和clone方法。对远程方法使用以上三种检测时，不会考虑对象内容。不能直接克隆远程对象。

远程对象激活：
    激活机制允许延迟构造远程对象，仅当至少一个客户端调用远程对象上的方法时，才去构造该远程对象。
    远程对象类通过继承Activatable类而不是UnicastRemoteObject类来使用激活机制。
    实现标准：该远程对象构造器必须包含以下两个参数：
        一个激活ID（只需传递个父类构造器）
        一个包含所有构造信息的对象，包装为MarshalledObject
        如果需要多个构造参数，必须将它们打包成为一个对象。

        构造激活描述符：MarshalledObject<T> param = new MarshalledObject<T>(constructionInfo);

        T constructionInfo = param.get();